<?xml version="1.0" encoding="UTF-8"?>
<document>
	<properties>
		<title>Introduction to as3commons-bytecode</title>
		<author email="scab@dds.nl">Roland Zwaga</author>
	</properties>
	<body>

		<section name="Introduction">
		
			<p>The most important class in this library is <code>ByteCodeType</code> which will parse
			the currently loaded bytecode and populate its cache with <code>ByteCodeType</code> instances
			for each class that was parsed.</p>
			
			<p>There are two static methods on the <code>ByteCodeType</code>:<br/>
			<code>ByteCodeType.fromLoader(loader:LoaderInfo)</code><br/>
			and
			<code>ByteCodeType.fromByteArray(input:ByteArray, applicationDomain:ApplicationDomain = null)</code></p>
			
			<p>Both methods have the same end result, they just start off with a different parameter.<br/>
			When using <code>fromLoader()</code> simply pass a valid <code>LoaderInfo</code> instance to it and it will
			pass its <code>.bytes</code> and <code>.applicationDomain</code> to the <code>fromByteArray()</code> method.</p>
			
			<p>For example like this:
				<div class="source">
					ByteCodeType.fromLoader(Application.loaderInfo);
				</div>
			Or in Flex 4:
				<div class="source">
					ByteCodeType.fromLoader(FlexGlobals.topLevelApplication.loaderInfo);
				</div>
			When RSL's have been loaded, use the <code>systemManager.preloadedRSLs</code> property to loop through
			the loaderInfo instances of each RSL:
				<div class="source">
					<pre>
for (var info:* in systemManager.preloadedRSLs) {
	ByteCodeType.fromLoader(info);
}
					</pre>
				</div>
			</p>

			<p>When a SWF has been loaded manually, pass it as a <code>ByteArray</code> to the <code>fromByteArray()</code>
			method along with an associated <code>ApplicationDomain</code>.
				<div class="source">
					<pre>
[Embed(source="someswf.swf", mimeType="application/octet-stream")]
private var swfInput:Class;

function parseSWF():void {
	var ba:ByteArray = new swfInput() as ByteArray;
	ByteCodeType.fromByteArray(ba, ApplicationDomain.currentDomain);
}
					</pre>
				</div>
			</p>
			
			<p>After parsing <code>ByteCodeTypes</code> can be retrieved by calling these static methods:
			<ul>
				<li>forInstance(instance:*, applicationDomain:ApplicationDomain = null)</li>
				<li>forClass(clazz:Class, applicationDomain:ApplicationDomain = null)</li>
				<li>forName(name:String, applicationDomain:ApplicationDomain = null)</li>
			</ul>
			</p>
			
			<p>To loop through all the generated <code>ByteCodeTypes</code> use the <code>getKeys()</code> method
			on the <code>TypeCache</code> instance:
				<div class="source">
					<pre>
var typeCache:TypeCache = ByteCodeType.getTypeProvider().getTypeCache();
for each (var key:String in keys) {
	var type:ByteCodeType = typeCache.get(key) as ByteCodeType;
	/* ... do something... */
}
					</pre>
				</div>
			</p>
			
		</section>
		
		<section name="Metadata scan">
			<p>Having the full bytecode reflection data is not always useful and the time it takes to parse and
			extract the data might not always be worth the loading time.</p>
			<p>There is also a more lightweight way of extracting just some bits and pieces from the bytecode that
			normally isn't available through <code>describeType()</code>.</p>
			<p>Here is a way to generate a lookup for class-level metadata annotations and their corresponding class names:
				<div class="source">
					<pre>
var metaDataLookup:Object = ByteCodeType.metaDataLookupFromLoader(loader);
var definitionNames:Array = metaDataLookup['Mixin'];
for(var i:uint=0; i &lt; definitionNames.length;i++){
	var type:Type = Type.forName(definitionNames[i]);
	/* ... do something... */
}
					</pre>
				</div>
			</p>
			<p>Generating this list using <code>metaDataLookupFromLoader(loader)</code> is much, much faster than reading
			all of the reflection data.</p>
			<p>The list can later be accessed using the <code>ByteCodeTypeCache.metaDataLookup</code> property or using the
			<code>ByteCodeTypeCache.getClassesWithMetaData(metaDataName)</code> method.</p>
			<p>At the same time a full list of definition names contained within the specified bytecode will be populated.<br/>
			To retrieve this list use this <code>ByteCodeTypeCache</code> property:
				<div class="source">
					<pre>
var typeCache:ByteCodeTypeCache = ByteCodeType.getTypeProvider().getTypeCache() as ByteCodeTypeCache;
var definitionNames:Array = typeCache.definitionNames;
for(var i:uint=0; i &lt; definitionNames.length;i++){
	var type:Type = Type.forName(definitionNames[i]);
	/* ... do something... */
}
					</pre>
				</div>
			</p>
			<p>Notice that to retrieve the type information the regular as3commons-reflect <code>Type</code> is used. Combing as3commons-bytecode
			and -reflect can yield the most efficient result in this way.</p>
			<blockquote>Note: the definitionNames list and metadata lookup property are of course also generated when the full bytecode
			reflection data is generated.</blockquote>
		</section>

	</body>
</document>

